<h1 id="java-api">
  Java API
</h1>
<p>
  The OpenAudioMc Java API is split into three parts, these are
  <br>
  -
  <strong>
    Client
  </strong>
  All player related functions (events, hooks, etc)
  <br>
  -
  <strong>
    WorldApi
  </strong>
  Hooks into the region and physical speaker system
  <em>
    (only accessible through Spigot)
  </em>
  <br>
  -
  <strong>
    MediaApi
  </strong>
  Hooks and controls towards controls
  <br>
  -
  <strong>
    RegistryApi
  </strong>
  Access to the OARegistry, for adding sub-commands and source middleware (also known as mutations), and voicechat player filters
</p>
<p>
  To get started, clone the github repository and build the latest release locally through maven, then add it in your project by adding the following to your pom
</p><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.craftmend.openaudiomc&lt;/groupId&gt;
    &lt;artifactId&gt;OpenAudioMc&lt;/artifactId&gt;
    &lt;version&gt;{{ Release version }}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>
  You can then obtain your api instance with
</p><pre><code>AudioApi api = AudioApi.getInstance();
</code></pre>
<p>
  <br/>
</p>
<h2 id="using-events">
  Using events
</h2>
<p>
  OpenAudioMc has an internal event driver which is used to process requests and important state changes.
  <br>
  You can access an instance of the driver to catch and process events yourself (this example shows you how to cancel voice chat for certain users)
</p><pre><code>AudioApi.getInstance().getEventDriver()
        // subscribe to an event
        .on(ClientRequestVoiceEvent.class)
        // what to do?
        .setHandler(event -&gt; {
            // event is a dynamic instance from the on method

            // check if the name isn&#39;t Mindgamesnl
            if (event.getRequester().getPlayer().getName() != &#34;Mindgamesnl&#34;) {
                // cancel the event, therefor blocking voice chat
                event.setCanceled(true);
            }
        });
</code></pre>
<p>
  OpenAudioMc has a few events build in, these are;
  <br>
  -
  <code>
    ClientConnectEvent
  </code>
  : Fires when a clients opens the web client, this is supported on all platforms.
  <br>
  -
  <code>
    ClientDisconnectEvent
  </code>
  : Fires when a clients closes the web client, this is supported on all platforms.
  <br>
  -
  <code>
    ClientRequestVoiceEvent
  </code>
  : A cancellable event that gets fired when a voicechat session is initializing. This only fires on the top-level server.
  <br>
  -
  <code>
    ClientErrorEvent
  </code>
  : Event that fires when the client encouters a media error (http failure when trying to load a media sound). This only fires on the top-level server.
  <br>
  -
  <code>
    StateChangeEvent
  </code>
  : Fires whenever the plugin changes state (idle, online, fatal error, etc). This only fires on the top-level server.
  <br>
  -
  <code>
    AccountAddTagEvent
  </code>
  : Fires whenever the server receives a new module/addon or update from the owning
  <a href="account.html" rel="nofollow">
    Craftmend Account
  </a>
  (example, VOICE_CHAT)
  <br>
  -
  <code>
    AccountRemoveTagEvent
  </code>
  : Mirror opposite of the
  <code>
    AccountAddTagEvent
  </code>
  <br>
  -
  <code>
    MicrophoneMuteEvent
  </code>
  : Fires when a player mutes their microphone
  <br>
  -
  <code>
    MicrophoneUnmuteEvent
  </code>
  : Fires when a player unmute their microphone (and when it activates for the first time)
  <br>
  -
  <code>
    PlayerEnterVoiceProximityEvent
  </code>
  : Fires when player A joins the voice range of player B
  <br>
  -
  <code>
    PlayerLeaveVoiceProximityEvent
  </code>
  : Fires when player A leaves the voice range of player B
  <br>
  -
  <code>
    PlayerLoudnessEvent
  </code>
  : Fires when a the speaking loudness of a player changes (between normal, whispering and shouting)
  <br>
  -
  <code>
    ClientPreAuthEvent
  </code>
  : A cancellable event that fires whenever a web client attempts to login. Canceling the event will block the login.
  <br>
  -
  <code>
    VoiceChatPeerTickEvent
  </code>
  : This event fires before
  <strong>
    AND
  </strong>
  after voicechat peer updates (it has a variable letting you know if it was pre-or post)
  <br>
  -
  <code>
    SystemReloadEvent
  </code>
  : Called whenever the plugin reloads completely or updates state
  <br>
  -
  <code>
    ConfigurationPushEvent
  </code>
  : Fires whenever a new version of the config.yml is loaded through networking, migrations or perhaps redis. It contains the (supposedly) yaml file content as a string.
  <br>
  <br/>
</p>
<h2 id="getting-a-client">
  Getting a Client
</h2>
<p>
  A client object resembles the web-connection of a given player and contains api methods (like
  <code>
    isConnected()
  </code>
  ,
  <code>
    onConnect
  </code>
  etc) and is used to specify a player in other API methods.
  <br>
  You can request a Client by Player-UUID on both bungeecord and spigot, but note that it’ll only be available a few ticks after joining. Example for getting my own connection:
</p><pre><code>Client mindgamesnl = api.getClient(UUID.fromString(&#34;f0c8657b-f384-4df6-9d66-e9f36c36ce8a&#34;));
</code></pre>
<p>
  We can also hook on connection events, which is as simple as
</p><pre><code>mindgamesnl.onConnect(() -&gt; {
    // I opened the web client!
});
</code></pre>
<p>
  <br/>
</p>
<h2 id="playing-a-sound">
  Playing a sound
</h2>
<p>
  Starting a simple sound is as easy as
</p><pre><code>api.getMediaApi().playMedia(client, &#34;https://example.com/a.mp3&#34;);
</code></pre>
<p>
  but we can get a lot more creative then that with media options (like setting a Sound ID, playback volume etc), which still is pretty simple, starting a looping sound at half volume with the id “example” would be like
</p><pre><code>MediaOptions options = new MediaOptions();
options.setLoop(true);
options.setId(&#34;example&#34;);
options.setVolume(50);
api.getMediaApi().playMedia(client, &#34;https://example.com/a.mp3&#34;, options);
</code></pre>
<p>
  <br/>
</p>
<h2 id="stopping-sounds">
  Stopping sounds
</h2>
<p>
  Stopping sounds is even simpler, we can stop all normal sounds through
</p><pre><code>api.getMediaApi().stopMedia(client);
</code></pre>
<p>
  or stop a single sound with the ID “example” with
</p><pre><code>api.getMediaApi().stopMedia(client, &#34;example&#34;);
</code></pre>
<p>
  <br/>
</p>
<h2 id="spatial-audio">
  Spatial Audio
</h2>
<p>
  Explosions are cool, but explosions that spook the living ghost out of someone are even cooler. OpenAudioMc supports spatial audio, and we can simply create it like this
</p><pre><code>String spatialSoundId = api.getMediaApi().playSpatialSound(client, &#34;https://example.com/a.mp3&#34;, x, y, z, 10, true);
</code></pre>
<p>
  This will start a 3D spatial sound at a given location for the player with a radius of 10 blocks. You can also just make a simple sound (so one that just does volume instead of 3D orientation by setting the mode to false, which is the last argument).
  <br>
  the
  <code>
    playSpatialSound
  </code>
  method returns a string, which is the spatial-id for that player (and unique to that player). You can remove it again with
</p><pre><code>api.getMediaApi().stopSpatialSound(client, spatialSoundId);
</code></pre>
<p>
  <br/>
</p>
<h2 id="hooking-into-internal-services-and-using-dependency-injection">
  Hooking into internal services and using dependency injection
</h2>
<p>
  Most of the internal codebase was re-written and refactored during the 6.5.5 update, where we migrated to a custom service manager with support for annotation based dependency injection, service abstraction and to provide pointer safety during reloads.
  <br>
  The service manager is registered in the main
  <code>
    OpenAudioMc
  </code>
  class and is accessible through all platforms. The entire ecosystem consists of two main registration types types
</p>
<ul>
  <li>
    <strong>
      Services
    </strong>
    are static code implementations that can be injected, requested and manipulated after loading (or being requested, in which case they’ll be loaded if they weren’t already. So calling
    <code>
      OpenAudioMc.getService(NotLoadedByDefault.class).something()
    </code>
    will delay the execution of the
    <code>
      something()
    </code>
    call, while it’s preparing the
    <code>
      NotLoadedByDefault
    </code>
    service and it’s dependencies). Services like this can be registered through
    <br>
    <code>
      java
      serviceManager.loadServices(
      FirstService.class,
      SecondService.class
      );
    </code>
    <br>
  </li>
  <li>
    <strong>
      Mapped Values
    </strong>
    Some services might have different implementations based on the platform, but are accessed by a shared source (example, having a
    <code>
      INetworkingService
    </code>
    interface, being implemented as
    <code>
      FirstnetworkingImpl
    </code>
    and
    <code>
      SecondNetworkingImpl
    </code>
    ) in which case you can register the interface with a value, so you can use dependency injection through the interface, and receive the appropriate implementation class. Example registration
    <br>
    <code>
      java
      OpenAudioMc.getInstance().getServiceManager().registerDependency(TaskService.class, invoker.getTaskProvider());
    </code>
    <br>
    This also means that you can register custom variables (identified by classes or interfaces) and have them injected with a default value or implementation.
    <br>
  </li>
</ul>
<p>
  There are a few ways to receive services, simplest one being the most common one, which is by just requesting the service manually. You can do this at any time through
</p><pre><code>// Get the current MyService instance, or initialize it if it isn&#39;t mapped yet
MyService myService = OpenAudioMc.getService(MyService.class);
</code></pre>
<p>
  Or you can alternatively use dependency injection using the
  <code>
    @Inject
  </code>
  annotation. This supports values and constructors.
</p>
<p>
  Field example:
</p><pre><code>public class TestService extends Service {
    
    // inject the main openaudio instance
    @Inject
    private OpenAudioMc openAudioMc;
    
    public TestService() {
        // this module is being loaded
    }
    
    @Override
    public void onEnable() {
        // the injections have been done, so we can safely call this.openAudioMc
    }
    
}
</code></pre>
<p>
  or through the constructor, like so
</p><pre><code>public class TestService extends Service {

    @Inject
    public TestService(OpenAudioMc openAudioMc, NetworkingService networkingService) {
        // both the &#39;openAudioMc&#39; and &#39;networkingService&#39; parameters will be injected during init
    }
    
}
</code></pre>
<p>
  <strong>
    NOTE THAT DEPENDENCY INJECTION ONLY WORKS WHEN YOUR OWN CLASS IS BEING LOADED AS A SERVICE
  </strong>
  ApiResponse.java:24
</p>
<p>
  <br/>
</p>
<h2 id="k-v-cache">
  K/V Cache
</h2>
<p>
  Keeping track of all spatial ID’s can be a pain, so we can keep track of it with a simple map. You can just
  <code>
    put
  </code>
  and
  <code>
    get
  </code>
  player metadata via the map we provide with the
  <code>
    getKeyValue
  </code>
  method in Client
</p>